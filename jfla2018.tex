% Conference: JFLA 2018, short paper
%
% Page limit: 6 pages, including references

\documentclass[a4paper]{easychair}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[francais]{babel}
\usepackage{mathpartir}
\usepackage{wasysym}
\usepackage{listings}
\usepackage{alltt}

% % for review: page and line numbers "if possible"
% \usepackage{lineno}
% \linenumbers
% \pagestyle{plain}

\title{Génération aléatoire de programmes guidée par la vivacité}
% \title{Liveness-Driven Random Program Generation}
\author{Gergö Barany\inst{1} et Gabriel Scherer\inst{2}}
\institute{
Inria Paris \\
\email{gergo.barany@inria.fr}
\and
Inria Saclay \\
\email{gabriel.scherer@gmail.com}
}

\titlerunning{Génération aléatoire guidée par la vivacité}
\authorrunning{G. Barany et G. Scherer}

% macros go here
\newcommand\ldrgen{\texttt{ldrgen}}
\newcommand{\liveout}[1]{\ensuremath{#1^{\circ}}}
\newcommand{\livein}[1]{\ensuremath{#1^{\bullet}}}
\newcommand{\triple}[3]{\ensuremath{
    \left\langle#1\right\rangle \ #2 \ \left\langle#3\right\rangle
}}
\def\union{\cup}

% en Français la norme est de mettre en italique
% les expressions en langue étragère
\newcommand{\anglais}[1]{\textit{#1}}

% make listings not super-ugly
\lstset{language=[Objective]Caml,columns=fullflexible,emphstyle=\emph,
        mathescape=true,showstringspaces=false,stringstyle=\texttt}

\begin{document}
\maketitle
\thispagestyle{plain}

\begin{abstract}
Les programmes générés aléatoirement sont un bon moyen de tester des
compilateurs et des outils d'analyse de logiciel. Des centaines de bogues
ont été trouvé dans des compilateurs C très utilisés (GCC, Clang) par des
tests aléatoires. Pourtant, les générateurs existants peuvent générer
beaucoup de code mort (dont les résultats ne sont jamais utilisés). Compiler
un tel programme laisse relativement peu de possibilités d'exercer les
optimisations complexes du compilateur.

Pour résoudre ce problème, nous proposons la génération aléatoire de
programmes guidée par la vivacité. Dans cette approche, le programme aléatoire
est construit \anglais{bottom-up}, en combinaison avec une analyse de flot de
données structurelle pour assurer que le système ne génère jamais de code
mort.

L'algorithme est implanté dans un greffon pour l'outil Frama-C. Nous
l'évaluons en comparaison avec Csmith, le générateur aléatoire standard pour
le langage C. Les programmes générés par notre outil compilent vers une plus
grande quantité de code machine, avec une plus grande variété
d'instructions.

Ce papier est une version courte d'un article présenté à LOPSTR~2017.
\end{abstract}

% \keywords{code generation, random testing, data-flow analysis, program
% optimization}


\section{Motivation}

Les compilateurs pour les langages de programmation modernes sont
compliqués et difficiles à comprendre. Malgré les avances en vérification de
compilateurs~\cite{leroy-2009,tan-2016}, la plupart des compilateurs
réalistes ne sommes pas vérifiés. Il faut de tests pour avoir de la
confiance en leur correction. Une approche populaire est le test aléatoire,
fait avec des fichiers d'entrée produits par un générateur aléatoire de
programmes. L'outil le plus connu dans ce domaine est Csmith, un générateur
aléatoire de programmes C. Csmith est très puissant~: il a trouvé des
centaines de bogues dans des compilateurs très utilisés comme GCC et Clang,
et même dans des parties non vérifiées du compilateur vérifié
CompCert~\cite{csmith-2011}.

Dans un projet de tests des optimisations effectués par des compilateurs C
nous avions besoin d'un générateur aléatoire de code C. L'objectif était de
générer des grandes fonctions effectuant des calculs compliqués, sans appels
de fonctions, pour pouvoir analyser le code machine optimisé généré par des
compilateurs différents. Csmith peut être configuré pour en tel usage, mais
nous avons vite trouvé que le compilateur enlève presque tous les calculs
présents au niveau code source. Même les boucles imbriquées entières
disparaissent souvent dans le code machine compilé à partir du code source
généré par Csmith. Ceci nous empêche de faire les analyses intéressantes sur
la code machine finale.

Le problème de base est que Csmith génère des programmes qui ne contiennent
presque que de~\emph{code mort}~: des calculs dont les résultants ne sont
jamais utilisés. Les compilateurs enlevent tout le code mort, laissant très
peu de possibilités d'appliquer nos analyses.

Cet article décrit \ldrgen, un nouveau générateur de code C guidée par une
analyse de vivacité pour éviter de générer du code mort.


\section{Analyse de la vivacité}

Une variable est~\emph{vivante} à un point dans un programme si sa valeur a
ce point peut être utilisée plus tard. Sinon, elle est~\emph{morte}. De la
même façon, une affectation~\(v = e\) est vivante si elle définit une
variable vivante, et morte sinon. Par exemple, dans un morceau de code
comme~\texttt{x = y + z; return y}, la variable~\texttt{x} est morte juste
après son affectation car sa valeur n'est jamais utilisée. L'affectation
elle-même est donc morte aussi, et elle peut être enlevée du programme sans
changer son sens.

Notre objectif est de ne générer pas de code mort, et en particulier, de ne
générer que des programmes dans lesquels toutes les affectations sont
vivantes.

\subsection{Analyse itérative}

L'analyse de la vivacité est un analyse classique de flot de
données~\cite{nielson.etal-1999}. Elle parcourt le graphe de flot de
contrôle du programme en arrière et itère jusqu'à trouver un point fixe.
Chaque instruction~\(S\) est liée à deux ensembles de variables vivantes
juste avant~(\(\livein{S}\)) et juste après~(\(\liveout{S}\)) l'instruction.
Ces ensembles sont liés par les équations spécifiques à l'instruction qui
décrivent la propagation de l'information. Pour une affectation~\(v = e\) de
la valeur d'une expression~\(e\) contenant l'ensemble de variables~\(FV(e)\)
à la variable~\(v\), la propagation est faite par l'équation suivante:
\[
\livein{S} = (\liveout{S} \setminus \{v\}) \union FV(e)
\]

Pour une instruction de branchement avec une condition~\(c\) (comme
\(S = \mbox{\texttt if (\(c\)) \dots}\)), l'analyse unit l'information de
tous les successeurs dans le graphe de flot de contrôle et rajoute les
variables de la condition:
\[
\livein{S} = \bigcup_{S_i \in \mathit{succ}(S)} \livein{S_i} \cup FV(c)
\]

Les boucles génèrent des systèmes d'équations récursifs. Ces systèmes sont
traditionnellement résolus par itération jusqu'à obtenir un point fixe
minimal comme solution.

\subsection{Analyse structurelle de programmes sans code mort}

L'analyse de flot de données sur le graphe de flot de contrôle est pratique
pour identifier le code mort dans un programme donné. Cependant, notre
objectif n'est pas d'analyser des programmes donnés mais d'utiliser
l'analyse pour guider la génération de code afin d'éviter de générer du code
mort. Nous voudrions éviter de construire un graphe de flot de contrôle et
de calculer les points fixes pour les boucles par itération.

Nous avons donc décidé d'essayer une approche structurelle basée sur la
structure de l'arbre de syntaxe abstraite. Les approches structurelles ne
sont appropriées qu'aux programmes structurés (sans~\texttt{goto}
etc.), mais cela suffit pour notre générateur.

L'analyse est présentée en Figure~\ref{fig:rules} comme un système de règles
d'inférence. L'information inférée sont des
triples~\(\triple{\livein{S}}{S}{\liveout{S}}\) d'une instruction~\(S\) et
ses ensembles de variables vivantes avant et après l'instruction
(\(\livein{S}\), \(\liveout{S}\)). Les règles contiennent deux sortes
d'hypothèses~: L'une sont les équations de propagation de l'information de
l'analyse de flot de données. En particulier, la règle~\textsc{Assign} pour
les affectations de la forme~\(v = e\) a comme hypothèse
l'équation~\(\livein{S} = (\liveout{S} \setminus \{v\}) \union FV(e)\), ce
qui est identique au cas de l'analyse de flot de données itérative.

La deuxième sorte d'hypothèses sont les conditions pour assurer que les
programmes qui contiennent du code mort ne sont pas acceptés par le système.
La condition la plus importante est celle de la règle~\textsc{Assign}: Une
affectation d'une variable~\(v\) ne peut être acceptée que si~\(v\) est
vivante après l'affectation. De la même façon, la condition~\(S_1 \neq \{\}
\lor S_2 \neq \{\}\) pour~\textsc{If} assure que les instructions de
branchement inutiles comme~\texttt{if (x) \{\} else \{\}} ne sont pas
acceptées.

Un programme~\(S\) ne contient pas de code mort si le
triple~\(\triple{\livein{S}}{S}{\emptyset}\) peut être dérivée dans le
système de règles d'inférence.

Le traitement de boucles est plus compliqué à cause de la dépendance
cyclique entre l'ensemble~\(\livein{B}\) de variables vivantes au début du
corps~\(B\) de la boucle, et l'ensemble~\(\liveout{B}\) de variables
vivantes à la fin du corps de la boucle. La condition de minimalité exprime
que la solution désirée est un point fixe minimale du système d'équations.
Un point fixe unique minimale existe toujours~\cite{nielson.etal-1999}.



\section{Quelques autres sections\dots}

\begin{figure}
\[
\inferrule*[left=Return]{
}{
    \triple{\{v\}}{\mathtt{return}\ v}{\emptyset}
}
\qquad
\inferrule*[left=Skip]{
    L \neq \emptyset
}{
    \triple{L}{\mathtt{\{\}}}{L}
}
\]

\[
\inferrule*[left=Assign]{
    v \in \liveout{S} \\
    \livein{S} = (\liveout{S} \setminus \{v\}) \union FV(e)
}{
    \triple{\livein{S}}{v\ \mathtt{=}\ e}{\liveout{S}}
}
\]

\[
\inferrule*[left=Sequence]{
    \triple{\livein{S_1}}{S_1}{\livein{S_2}} \\
    \triple{\livein{S_2}}{S_2}{\liveout{S_2}} \\
    \livein{S_2} \neq \emptyset
}{
    \triple{\livein{S_1}}{S_1\ \mathtt{;}\ S_2}{\liveout{S_2}}
}
\]

\[
\inferrule*[left=If]{
    \triple{\livein{S_1}}{S_1}{\liveout{S}} \\
    \triple{\livein{S_2}}{S_2}{\liveout{S}} \\
    \livein{S} = \livein{S_1} \union \livein{S_2} \union FV(c) \\
    S_1 \neq \{\} \lor S_2 \neq \{\}
}{
    \triple{\livein{S}}
           {\mathtt{if\ (}c\mathtt{)}\ S_1\ \mathtt{else}\ S_2}
           {\liveout{S}}
}
\]

\[
\inferrule[While]{
    \triple{\livein{B}}{S}{\liveout{B}} \\
    \liveout{B} = \liveout{S} \union \livein{B} \union FV(c)
        \mbox{ (minimal)} \\
    % \liveout{B}\ \mbox{minimal} \\
    \livein{S} = \livein{B} \union \liveout{S} \\
    \liveout{S} \neq \emptyset
}{
    \triple{\livein{S}}
           {\mathtt{while\ (}c\mathtt{)}\ S}
           {\liveout{S}}
}
\]
\caption{Système de règles d'inférence pour la recognition de programmes
sans code mort}
\label{fig:rules}
\end{figure}

\begin{figure}
\lstset{emph={v,L,S,e,code,c,t,f,V,B}}
\begin{lstlisting}
let random_statements L code =
    if L $\neq \emptyset$ then
        let (S, $L'$) = random_statement L;
        random_statements $L'$ (S :: code)
    else
        (code, L)

let random_statement L =
    let statement_generator = random_select [assignment; branch; loop];
    statement_generator L

let assignment L =
    let v = random_select L;
    let e = random_expression ();
    ("$v$ = $e$", $(L \setminus \{v\}) \union FV(e)$)

let branch L =
    let (t, $L_1$) = random_statements L [];
    let (f, $L_2$) = random_statements L [];
    let c = random_expression ();
    ("if ($c$) $t$ else $f$", $L_1 \union L_2 \union FV(c)$)

let loop L =
    (* See main text for explanation. *)
    let c = random_expression ();
    let $B'$ = random_variable_set ();
    let (code, L') = random_statements $(L \union B' \union FV(c))$ [];
    let $V = \{ b \in B' \mid b \notin L' \mbox{ or \(b\) not used in \(S\)}\}$;
    if $V \neq \emptyset$ then
        let e = random_expression_on_variables V;
        let v = random_select $L'$;
        let code' = "$v$ = $e$" :: code;
        ("while ($c$) $code'$", $(L' \setminus \{v\}) \union V \union L$)
    else
        ("while ($c$) $code$", $L' \union L$)

(* Start generation with the terminating return statement. *)
let v = random_variable ()
let (code, L) = random_statements {v} ["return $v$"]
\end{lstlisting}
\caption{Pseudocode of a liveness-driven random program generator.}
\label{fig:generator}
\end{figure}

\begin{quote}
\begin{alltt}
v = \(\dots\);
for (unsigned int i = 0; i < N; i++) \{
    v = v \(\circ\) \(f(\mbox{\texttt{arr[i]}})\);
\}
\end{alltt}
\end{quote}


\begin{table}
\caption{Comparison of code generated by Csmith and \ldrgen\ in 1000 runs
each.}
\label{tab:results}

\centering
\begin{tabular}{l@{\ } | @{\ }l @{\quad} r @{\quad} r @{\quad} r @{\quad} r}

& generator & min & median & max & total \\
\hline
lines of code & Csmith
    & 25 & 368.5 & 2953 & 459021 \\
& \ldrgen
    & 12 & 411.5 & 1003 & 389939
    \\[1ex]
instructions & Csmith
    & 1 &  15.0 & 1006 &   45606 \\
& \ldrgen
    & 1 & 952.5 & 4420 & 1063503
    \\[1ex]
unique opcodes & Csmith
    & 1 &  8 &  74 & 146 \\
& \ldrgen
    & 1 & 95 & 124 & 204
    \\
% 
% type conversions, vector instructions (!)
% 
% https://github.com/gergo-/ldrgen
\end{tabular}
\end{table}


\bibliography{lopstr2017}
\bibliographystyle{alpha}

\end{document}
